.TH "DBJsonParser" 3 "Thu Aug 9 2012" "Version 1.0" "Yini" \" -*- nroff -*-
.ad l
.nh
.SH NAME
DBJsonParser \- 
.PP
The JSON parser class\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#import <DBJsonParser\&.h>\fP
.PP
Inherits \fBDBJsonBase\fP, and \fB<DBJsonParser>\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "(id) - \fBfragmentWithString:\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The JSON parser class\&. 

JSON is mapped to Objective-C types in the following way:
.PP
.PD 0
.IP "\(bu" 2
Null -> NSNull 
.IP "\(bu" 2
String -> NSMutableString 
.IP "\(bu" 2
Array -> NSMutableArray 
.IP "\(bu" 2
Object -> NSMutableDictionary 
.IP "\(bu" 2
Boolean -> NSNumber (initialised with -initWithBool:) 
.IP "\(bu" 2
Number -> NSDecimalNumber
.PP
Since Objective-C doesn't have a dedicated class for boolean values, these turns into NSNumber instances\&. These are initialised with the -initWithBool: method, and round-trip back to JSON properly\&. (They won't silently suddenly become 0 or 1; they'll be represented as 'true' and 'false' again\&.)
.PP
JSON numbers turn into NSDecimalNumber instances, as we can thus avoid any loss of precision\&. (JSON allows ridiculously large numbers\&.) 
.SH "Member Function Documentation"
.PP 
.SS "- (id) fragmentWithString: (id)repr"


.SH "Author"
.PP 
Generated automatically by Doxygen for Yini from the source code\&.
